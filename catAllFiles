#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# catAllFilesWatch: A simplified file watcher for macOS that processes files on change
# -----------------------------------------------------------------------------
# Usage:
#   catAllFilesWatch [--withSchema schema.prisma] [--outDir <dir>] [--force] <scan_dir> <dir1> <dir2> <dir3> ...
#
# Options:
#   --withSchema schema.prisma    Schema file to use for model lookups
#   --outDir <dir>                Where to save output files (defaults to ~/Downloads)
#   --force                       Process all files on any change instead of only changed files
#
# Example:
#   catAllFilesWatch --withSchema prisma/schema.prisma prisma/seeds prisma/mutations src/resolvers/
# -----------------------------------------------------------------------------

# Process arguments
SCHEMA_FILE=""
OUTPUT_DIR=~/Downloads
SCAN_DIR=""
FORCE_MODE=false
DIRECTORIES=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --withSchema)
            SCHEMA_FILE="$2"
            if [ ! -f "$SCHEMA_FILE" ]; then
                echo "Error: Schema file '$SCHEMA_FILE' not found"
                exit 1
            fi
            shift 2
            ;;
        --outDir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --force)
            FORCE_MODE=true
            shift
            ;;
        *)
            if [[ -z "$SCAN_DIR" ]]; then
                SCAN_DIR="$1"
            else
                DIRECTORIES+=("$1")
            fi
            shift
            ;;
    esac
done

# Validate arguments
if [[ -z "$SCAN_DIR" ]]; then
    echo "Error: No scan directory specified"
    echo "Usage: $0 [--withSchema schema.prisma] [--outDir <dir>] <scan_dir> <dir1> <dir2> ..."
    exit 1
fi

# Add scan dir to directories if not already included
DIRECTORIES+=("$SCAN_DIR")

# Remove duplicates from directories
DIRECTORIES=($(printf "%s\n" "${DIRECTORIES[@]}" | sort -u))

# Display watch mode
if [ "$FORCE_MODE" = true ]; then
    echo "üîÑ Force mode enabled: Will process ALL files on any change"
else
    echo "üîç Smart mode enabled: Will only process changed files"
fi

# Check if directories exist
for dir in "${DIRECTORIES[@]}"; do
    if [ ! -d "$dir" ]; then
        echo "Warning: Directory '$dir' does not exist"
    else
        echo "Watching directory: $dir"
    fi
done

# Create output directory
mkdir -p "$OUTPUT_DIR"
echo "Output files will be saved to: $OUTPUT_DIR"

# Get list of base names from scan directory
BASENAMES=()
for file in "$SCAN_DIR"/*; do
    if [[ -f "$file" ]]; then
        baseName=$(basename "$file" | cut -d '.' -f1)
        BASENAMES+=("$baseName")
    fi
done

echo "Found ${#BASENAMES[@]} base names to process in $SCAN_DIR"

# Process all base names
process_all_files() {
    echo "Processing all base names..."
    local successful=0
    local failed=0
    local total=${#BASENAMES[@]}
    
    for ((i=0; i<total; i++)); do
        local baseName="${BASENAMES[$i]}"
        echo "[$(($i+1))/$total] Processing: $baseName"
        
        if process_file "$baseName"; then
            ((successful++))
        else
            ((failed++))
        fi
    done
    
    echo ""
    echo "Processing complete:"
    echo "- Total processed: $total"
    echo "- Successful: $successful"
    echo "- No content found: $failed"
    echo "- Output location: $OUTPUT_DIR"
}

# Process a specific base name
process_file() {
    local baseName="$1"
    local outputFile="$OUTPUT_DIR/${baseName}-code.ts"
    
    echo "Processing: $baseName"
    
    # Add header with metadata
    {
        echo "// Generated by catAllFilesWatch on $(date)"
        echo "// Base name: $baseName"
        echo "// Directories scanned: ${DIRECTORIES[*]}"
        echo "// Schema file: ${SCHEMA_FILE:-None}"
        echo ""
        
        # Run catFiles and capture output
        if [[ -n "$SCHEMA_FILE" ]]; then
            catFiles --grep "$baseName" --withSchema "$SCHEMA_FILE" "${DIRECTORIES[@]}"
        else
            catFiles --grep "$baseName" "${DIRECTORIES[@]}"
        fi
    } > "$outputFile"
    
    # Check if file contains actual content beyond the header (5 lines)
    if [[ $(wc -l < "$outputFile") -gt 5 ]]; then
        echo "‚úÖ Processed $baseName -> $outputFile"
        return 0
    else
        echo "‚ùå No matching content found for $baseName"
        rm "$outputFile"  # Remove empty files
        return 1
    fi
}

# Find base name from file path
get_base_from_path() {
    local file="$1"
    local file_basename=$(basename "$file")
    
    # Try to match with known base names
    for base in "${BASENAMES[@]}"; do
        if [[ "$file_basename" == *"$base"* ]]; then
            echo "$base"
            return 0
        fi
    done
    
    # If no match, return the base filename without extension
    echo "${file_basename%.*}"
    return 1
}

# Track file modification times
declare -A FILE_TIMES

# Initial scan to build baseline
echo "Building initial file index..."
total_files=0
for dir in "${DIRECTORIES[@]}"; do
    if [[ -d "$dir" ]]; then
        while read -r file; do
            if [[ -f "$file" ]]; then
                # Get modification time
                mod_time=$(stat -f "%m" "$file" 2>/dev/null || stat -c "%Y" "$file" 2>/dev/null)
                FILE_TIMES["$file"]=$mod_time
                ((total_files++))
            fi
        done < <(find "$dir" -type f -not -path "*/\.*" -not -path "*/node_modules/*" 2>/dev/null || echo "")
    fi
done

echo "Watching $total_files files for changes..."
echo "Press Ctrl+C to stop watching."

# Set last run time
LAST_RUN=$(date +%s)
MIN_INTERVAL=2  # Minimum seconds between runs

# Polling loop
while true; do
    sleep 1
    changed=false
    changed_files=()
    
    for dir in "${DIRECTORIES[@]}"; do
        if [[ -d "$dir" ]]; then
            while read -r file; do
                if [[ -f "$file" ]]; then
                    # Get current modification time
                    current_time=$(stat -f "%m" "$file" 2>/dev/null || stat -c "%Y" "$file" 2>/dev/null)
                    
                    # If file is new or modified
                    if [[ -z "${FILE_TIMES[$file]}" || "${FILE_TIMES[$file]}" != "$current_time" ]]; then
                        changed=true
                        changed_files+=("$file")
                        FILE_TIMES["$file"]=$current_time
                    fi
                fi
            done < <(find "$dir" -type f -not -path "*/\.*" -not -path "*/node_modules/*" 2>/dev/null || echo "")
        fi
    done
    
    # Process changed files
    if [[ "$changed" == true ]]; then
        CURRENT_TIME=$(date +%s)
        if (( CURRENT_TIME - LAST_RUN >= MIN_INTERVAL )); then
            echo ""
            echo "üîÑ Changes detected at $(date '+%H:%M:%S')!"
            
            # Show first 3 changed files (max)
            for ((i=0; i<3 && i<${#changed_files[@]}; i++)); do
                echo "- ${changed_files[$i]}"
            done
            
            if [[ ${#changed_files[@]} -gt 3 ]]; then
                echo "- ...and $((${#changed_files[@]} - 3)) more files"
            fi
            
            # Process changes based on mode
            if [ "$FORCE_MODE" = true ]; then
                # Force mode: process all files
                echo "Force mode: processing all files..."
                process_all_files
            else
                # Smart mode: process only changed files
                echo "Smart mode: processing changed files..."
                # Process each changed file
                processed=false
                for file in "${changed_files[@]}"; do
                    base=$(get_base_from_path "$file")
                    if [[ -n "$base" ]]; then
                        process_file "$base"
                        processed=true
                    fi
                done
                
                # If no files were processed, inform the user
                if [ "$processed" = false ]; then
                    echo "‚ÑπÔ∏è No relevant files were found to process."
                fi
            fi
            
            LAST_RUN=$(date +%s)
            echo "Watching for more changes... (Press Ctrl+C to stop)"
        fi
    fi
done