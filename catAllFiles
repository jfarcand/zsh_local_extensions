#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# catAllFiles: Calls catFiles on all base names found in directories.
# -----------------------------------------------------------------------------
# Usage:
#   catAllFiles [--withSchema schema.prisma] [--scanDir <dir>] [--outDir <dir>] [--watch] <dir1> <dir2> <dir3> ...
#
# Options:
#   --withSchema schema.prisma    Schema file to use for model lookups
#   --scanDir <dir>               Directory to scan for base names (defaults to first directory)
#   --outDir <dir>                Where to save output files (defaults to ~/Downloads)
#   --watch                       Watch directories for changes and reprocess automatically
#
# Example:
#   catAllFiles --withSchema prisma/schema.prisma --watch prisma/seeds prisma/mutations src/resolvers/
# -----------------------------------------------------------------------------

# Process arguments
SCHEMA_FILE=""
SCAN_DIR=""
OUTPUT_DIR=~/Downloads
WATCH_MODE=false
DIRECTORIES=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --withSchema)
            SCHEMA_FILE="$2"
            if [ ! -f "$SCHEMA_FILE" ]; then
                echo "Error: Schema file '$SCHEMA_FILE' not found"
                exit 1
            fi
            shift 2
            ;;
        --scanDir)
            SCAN_DIR="$2"
            if [ ! -d "$SCAN_DIR" ]; then
                echo "Error: Scan directory '$SCAN_DIR' not found"
                exit 1
            fi
            shift 2
            ;;
        --outDir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --watch)
            WATCH_MODE=true
            shift
            ;;
        *)
            DIRECTORIES+=("$1")
            shift
            ;;
    esac
done

# Validate arguments
if [ ${#DIRECTORIES[@]} -eq 0 ]; then
    echo "Error: No directories specified"
    echo "Usage: $0 [--withSchema schema.prisma] [--scanDir <dir>] [--outDir <dir>] [--watch] <dir1> <dir2> ..."
    exit 1
fi

# If no scan directory specified, use the first directory
if [ -z "$SCAN_DIR" ]; then
    SCAN_DIR="${DIRECTORIES[0]}"
fi

# Function to process all files
process_files() {
    # Create output directory
    mkdir -p "$OUTPUT_DIR"
    echo "Output files will be saved to: $OUTPUT_DIR"

    # Count and track files for summary
    SUCCESSFUL=0
    FAILED=0
    PROCESSED=0

    # Get list of files to process
    BASENAMES=()
    for file in "$SCAN_DIR"/*; do
        if [[ -f "$file" ]]; then
            baseName=$(basename "$file" | cut -d '.' -f1)
            BASENAMES+=("$baseName")
        fi
    done

    echo "Found ${#BASENAMES[@]} base names to process in $SCAN_DIR"

    # Process each base name
    for baseName in "${BASENAMES[@]}"; do
        ((PROCESSED++))
        outputFile="$OUTPUT_DIR/${baseName}-code.ts"
        
        echo "[$PROCESSED/${#BASENAMES[@]}] Processing: $baseName"
        
        # Add header with metadata
        {
            echo "// Generated by catAllFiles on $(date)"
            echo "// Base name: $baseName"
            echo "// Directories scanned: ${DIRECTORIES[*]}"
            echo "// Schema file: ${SCHEMA_FILE:-None}"
            echo ""
            
            # Run catFiles and capture output
            if [[ -n "$SCHEMA_FILE" ]]; then
                catFiles --grep "$baseName" --withSchema "$SCHEMA_FILE" "${DIRECTORIES[@]}"
            else
                catFiles --grep "$baseName" "${DIRECTORIES[@]}"
            fi
        } > "$outputFile"
        
        # Check if file contains actual content beyond the header (5 lines)
        if [[ $(wc -l < "$outputFile") -gt 5 ]]; then
            echo "✅ Processed $baseName -> $outputFile"
            ((SUCCESSFUL++))
        else
            echo "❌ No matching content found for $baseName"
            rm "$outputFile"  # Remove empty files
            ((FAILED++))
        fi
    done

    echo ""
    echo "Processing complete:"
    echo "- Total processed: $PROCESSED"
    echo "- Successful: $SUCCESSFUL"
    echo "- No content found: $FAILED"
    echo "- Output location: $OUTPUT_DIR"
}

# Execute once initially
process_files

# If watch mode is enabled, continue watching for changes
if [ "$WATCH_MODE" = true ]; then
    echo ""
    echo "🔍 Watch mode enabled. Monitoring directories for changes..."
    echo "Press Ctrl+C to stop watching."
    
    # Determine which file watching tool to use
    WATCH_TOOL=""
    if command -v inotifywait >/dev/null 2>&1; then
        WATCH_TOOL="inotifywait"
    elif command -v fswatch >/dev/null 2>&1; then
        WATCH_TOOL="fswatch"
    else
        echo "Error: No file watching tool found."
        echo "Please install one of the following:"
        echo "  - Linux: inotify-tools package (provides inotifywait)"
        echo "  - macOS: fswatch (can be installed via Homebrew: brew install fswatch)"
        exit 1
    fi
    
    # Construct list of all directories to watch
    WATCH_DIRS=("$SCAN_DIR")
    for dir in "${DIRECTORIES[@]}"; do
        # Only add if not already in the list
        if [[ ! " ${WATCH_DIRS[*]} " =~ " ${dir} " ]]; then
            WATCH_DIRS+=("$dir")
        fi
    done
    
    # Add schema file directory if specified
    if [ -n "$SCHEMA_FILE" ]; then
        SCHEMA_DIR=$(dirname "$SCHEMA_FILE")
        if [[ ! " ${WATCH_DIRS[*]} " =~ " ${SCHEMA_DIR} " ]]; then
            WATCH_DIRS+=("$SCHEMA_DIR")
        fi
    fi
    
    echo "Watching directories: ${WATCH_DIRS[*]}"
    
    # Track last run time to prevent multiple runs in quick succession
    LAST_RUN=$(date +%s)
    MIN_INTERVAL=2  # Minimum seconds between runs
    
    # Start watching for changes based on available tool
    if [ "$WATCH_TOOL" = "inotifywait" ]; then
        echo "Using inotifywait for file monitoring..."
        # Start watching for changes with inotifywait
        while true; do
            # Wait for any file changes in any of the watched directories
            inotifywait -q -e modify,create,delete,move -r "${WATCH_DIRS[@]}" --exclude '\.git/'
            
            # Check if enough time has passed since last run
            CURRENT_TIME=$(date +%s)
            if (( CURRENT_TIME - LAST_RUN >= MIN_INTERVAL )); then
                echo ""
                echo "🔄 Changes detected! Re-processing files..."
                process_files
                LAST_RUN=$(date +%s)
            fi
        done
    elif [ "$WATCH_TOOL" = "fswatch" ]; then
        echo "Using fswatch for file monitoring..."
        # Use fswatch to monitor changes and trigger processing
        fswatch -o "${WATCH_DIRS[@]}" | while read; do
            # Check if enough time has passed since last run
            CURRENT_TIME=$(date +%s)
            if (( CURRENT_TIME - LAST_RUN >= MIN_INTERVAL )); then
                echo ""
                echo "🔄 Changes detected! Re-processing files..."
                process_files
                LAST_RUN=$(date +%s)
            fi
        done
    fi
fi